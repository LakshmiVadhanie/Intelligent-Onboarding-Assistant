{
  "content": "Threat Modeling\nThe threat modeling process, and the framework used by the GitLab Security Team.\nThreat modeling is the process of taking established or new procedures, and then assessing it for potential risks. For most tech companies, this usually involves code and coding changes. However this process can be adapted to any situation where there is a potential risk, and is something that many of us do every day. Choosing the longer well-lit walk to your car as opposed to the short cut through the darkened alley. Looking both ways before crossing the street. This is something we often do by instinct.\nWithin the context of GitLab, there are different risks we evaluate. Will my code change introduce a security vulnerability into the product? Will a radical new company policy being introduced create outside criticism and damage GitLabs reputation? When was the last time we evaluated this existing code library for vulnerabilities? What are the potential pitfalls our new sales campaign might face when moving into new markets? These are risks we deal with all of the time, just like every other company.\nGetting Started\nHere are a few resources to help get you started in threat modeling:\nWeve developed an issue template available\nhere\n(private link) that you can use to create an issue documenting your threat model. Its required that Engineering provide technical documentation when creating a threat model issue. We also request that the application decomposition, use case, external entrypoints, trust levels, data flow diagram as well as the previous security issues (if any) sections are filled out.\nThe basis of our threat modeling is modeled after\nPASTA\nIt should be noted that a full PASTA threat model is usually not required as it involves 7 steps, and in many cases only the steps 4, 5, and 6 are needed. To make it even easier, you can use\nSTRIDE\nto help define the threats.\nTherefore weve included a beginner-friendly\nhow-to guide to threat modeling\nwhich you should read if youre new to threat modeling. It includes a bit more detail about using STRIDE. If you need additional help, please ping the AppSec team or reach out in the #sec-appsec Slack channel.\nSamples of PASTA Evaluations\nHere is a\nreal sample of an evaluation\nof the install of a GitLab standalone instance in a hostile environment.\nMore samples will be added later.\nThreat Modeling Within GitLab\nThe most common use of threat modeling within a tech company like GitLab is our code base. The Security Team has developed a threat modeling framework for Engineering with the following in mind:\nEstablish a framework that is easy to understand and follow\nThe framework should enhance DevSecOps, and introduce minimal overhead\nThe framework should be based upon an existing framework with an established track record, if possible, as that may be more familiar to current GitLab team members\nAs the Security Team helps with the popular and successful Hackerone bug bounty program, handles compliance needs, and deals with security threats against our assets, having a framework that would allow us to provide feedback into the process of analyzing risk is extremely important in helping to determine actual outcomes\nThe framework should be flexible enough that it can be used outside of Engineering by other GitLab teams\nThe purpose of the GitLab Threat Modeling Process is to provide a starting point for future\nAppSec Code Reviews\n. Threat models are based on the conceptual architecture of the application and only utilize code to substantiate findings when possible.\nOne might ask why we are doing this. Our reasoning involves these important points:\nThe Security Team already performs risk analysis and assessments constantly, this gives us a common language\nA common language allows for better communications between Engineering groups, particularly in an all-remote company that makes use of asynchronous communications\nWhen dealing with partners, customers, and contributors, we have a common point of reference we can use for discussion\nBeing a secure company with a mature and robust code base is our goal, and this helps with that effort\nWe already have a large code base - instead of trying to rewrite and re-analyze everything from scratch, threat modeling gives us a tool to evaluate new changes to help mitigate future risks. As we triage security issues or introduce new security-related features, we have a tool that will allow us to work off some of the organization and technical debt associated with security and risk is easier-to-digest pieces.\nThe overall goal is not to create a rigid structure that must be strictly followed, but an adaptive tool that proactively helps uncover security risks before they occur and even chart out solutions based upon the likelihood of the risk.\nAfter evaluation of several popular frameworks, we elected to use the\nPASTA\nframework as a base, and with a few minor tweaks for GitLabs environment, weve completed the framework. An overview from the author of the original book can be found\nhere\n.\nWe still welcome changes to the framework and deem it to be as much of a living document as the rest of the handbook.\nThe Framework\nOur base framework is PASTA. PASTA is an acronym that stands for Process for Attack Simulation and Threat Analysis. It is a 7-step risk-based threat modeling framework.\nThere are several other threat modeling frameworks, however others were deemed either too focused on coding or too focused on attacks. PASTA has a much broader range and can easily scale up or scale down as needed, and most other threat modeling frameworks can map into it.\nOther threat modeling frameworks examined:\nSTRIDE\n. This has been used by Microsoft, and is primarily focused on threats themselves, and tends to lean toward known/existing threats. As they outgrew STRIDE, they developed\nSDL\n(that runs on Microsoft Windows) that allows them to define templates and evaluate threats. We do not run Windows, nor does our focus involve the existing templates they have designed for it. As a part of the overall development process within Microsoft, it is still more code-centric that we need.\nEvil Personas. The focus of Evil Personas similar to regular Personas, but the emphasis is on threat actors. it does not cover code-centric projects, just perceived threats. Useful, but limited as it assumes a threat is a person or group of people. Most persona scenarios are usually built in or added onto other threat models, refer to\nthis paper on Attack Personas\nfor a reference to the more aggressive side of personas in threat modeling.\nPlaying cards. There are several versions of this including\nElevation of Privilege\nExtremely useful tool, but better designed for in-person collaborations, and is more aligned with STRIDE in mind. Similar to Attack Trees, it focuses more on the attack end in reference to a chunk of infrastructure or code. This would be a fun thing to do at a future Contribute, but it does not scale well for a Zoom-based culture.\nAttack Trees\n. The focus is on attacks only, as a process to map flaws in existing code and systems.\nPASTA has a number of advantages for GitLab over other frameworks:\nRisk centric - mitigating what matters\nEvidence-based threat modeling\nHarvest threat intel to support threat motives\nLeverage threat data to support prior threat patterns\nFocus on probability of attack, likelihood, inherent risk, impact of compromise\nCollaborative\nPrioritization should define when and what apps to apply the threat model, and be apart of the threat model process itself\nPASTA has the advantage in that it can be adopted from code-based scenarios to infrastructure scenarios easily. It can be adapted to cover non-traditional threats, such as bad PR due to an executives social media posting or the companys selling of the GitLab product to a controversial organization. It can even be used to map in incident response scenarios, as it allows for threat reinforcement from threat intel sources including logs, intel services, and even previous incidents.\nPASTA Stages\nThere are seven stages to PASTA, here are our definitions. Note that while many of the examples are code-centric, these can be evolved over time to cover non-coding scenarios, such as third-party SaaS application approval, sales strategies and plan into new territories, and so on.\nStage I - Define objectives\nThis helps set the tone for the project or assessment. It considers the following:\nBusiness objectives. State the business objective of the project. This can be the purpose of the code, the change to the infrastructure, the goal of the marketing campaign, whatever the objective is.\nSecurity, Compliance, and Legal requirements. These are both guidelines and limits in a broad sense. For example, the licensing for a proposed third party application should be in order, the privacy policy of the new SaaS application being considered meets muster, or the new code does not require lowering security standards.\nBusiness impact analysis. This should include impact to mission and business processes, recovery processes, budget impact, and system resource requirements.\nOperational impact. This should include impact to existing processes already in use by operational personnel. For example, extra logging could be introduced that might impact interpretation of system events, increase the number of steps for future changes, or alter documented procedures for advanced troubleshooting.\nStage II - Define technical scope\nThis does not have to be tech per se, but should include project boundaries.\nBoundaries of technical environment. These are the boundaries related to the project itself. This should include the type of data (by classification) that will be touched with this project.\nInfrastructure, application, software dependencies. All of these need to be documented, including the level of impact. For example, if the project requires an upgrade to a subsystems library and the subsystem has access read-only access to RED data, this needs to be documented as it could impact other users of the subsystem as well as introduce a potential attack vector to RED data.\nStage III - Application Decomposition\nThis allows mapping of what is important to what is in scope.\nIdentify use cases, define application entry points and trust levels even if they are to remain unchanged as a result of the project.\nIdentify actors, assets, services, roles, and data sources.\nDocument data movement (in motion, at rest) via Data Flow Diagramming. Show trust boundaries, including existing as well as proposed changes.\nDocument all data touched and its classification.\nStage IV - Threat Analysis\nThis is where we mainly look to document relevant threats and threat patterns to the data we have gathered up until now.\nProbabilistic attack scenario analysis, where any scenario that could happen is at least listed.\nRegression analysis on security events, where we example events that touch on some of the same or similar components.\nThreat intel correlation, by taking data from logs, Hackerone reports, incidents, and other sources that can be used to indicate an attack scenario.\nStage V - Vulnerability and weakness analysis\nThis is were we examine the threats, ranking them and assessing their likelihood.\nExamine existing vulnerability reports and issues tracking.\nThreat to existing vulnerability mapping using threat trees.\nDesign Flaw analysis using use and abuse cases.\nScorings (CVSS) and Enumeration (CWE/CVE).\nImpacted systems, sub-systems, data. Are we adding to or altering something that has a history of exploitation. Is the current state vulnerable, and will this change potentially be influenced by or change that assessment.\nStage VI - Attack modeling\nWe go through the threats and turn them into attacks, by examining the attack surface before and after our proposed changes.\nAttack surface analysis for the impacted components.\nAttack tree development. This is where something like MITRE ATT&CK can assist.\nAttack  Vulnerability  Exploit analysis using attack trees.\nSummarize the impact and explain each risk.\nStage VII - Risk and Impact Analysis\nThis covers the development of the rationale for mitigation based upon residual risk.\nQualify and quantify the business impact.\nCountermeasure identification and residual impact.\nIdentify risk mitigation strategies. Effectiveness of mitigation(s) vs cost to implement mitigation.\nResidual benefits, as the implementation of a change to single component as a mitigation effort could mean increased security for other systems that access that component.\nThree Tiered Approach\nTo help with implementing and using the PASTA framework, we can use a three-tiered approach. This approach is as follows:\nBlind threat model\nGitLabs best practices applied to components of the project.\nMaps key goals of app or service and correlates to clear technical standards for architecture, hardening of server/service, app framework, containers, etc.\nBest practices per component. For example, TLS settings that are set to a GitLab standard, noting if our own standard is higher or lower than industry best practices.\nBest practices for coding are applied here as well, the Sec part of DevSecOps and our integration of this into CI/CD.\nSAST/DAST policies and scopes. We can eat our own dogfood to improve the quality of the changes we implement.\nApplies Stage I & Stage II of PASTA\nEvidence Driven threat model\nProof of a threat via numerous indicators as opposed to just theory or conjecture.\nIntegrate threat log data analysis.\nFocus on logs that support attack vector with the greatest motives (e.g. TLS MITM vs Injection-based attacks).\nCorrelate threat intel for foreseeing trends of attacks for target applications that are related to project components.\nApplies Stage III, IV, V of PASTA\nFull Risk Based Threat Model\nStatistical/probabilistic analysis on threat data & attack effectiveness\nConsider non-traditional threat vectors\nThis includes threat intel, H1 trends, existing logs\nSubstantiate the threats that are defined with real data\nApplies all stages of PASTA\nAdditional Resources\nHere are some helpful links.\nExcerpt from a Security Department Show and Tell discussing Threat Modeling\n.\nBlog post\nby\nMichael Henriksen\nthat talks about using Draw.io\navailable via diagrams.net\nto construct diagrams and flowcharts, and using them during threat modeling. Included is a\nlink\nto useful libraries for threat model diagrams.\nIn addition to\nElevation of Privilege\nthere is also\nOWASP Cornucopia\n, which leans more towards web-based applications.\nMITRE ATT&CK\n. This is not a framework used for threat modeling per se, but it could be adapted to and mapped to an existing threat modeling framework.\nThreat Modeling HowTo\nA howto for the threat modeling process at GitLab.\nLast modified February 4, 2025:\nChange ref links to regular links (\n64832a18\n)\nView page source\n-\nEdit this page\n-\nplease\ncontribute\n.",
  "metadata": {
    "url": "https://handbook.gitlab.com/handbook/security/product-security/application-security/threat-modeling/",
    "title": "Threat Modeling | The GitLab Handbook",
    "scraped_at": "2025-10-26T20:51:08.394110",
    "content_length": 14943,
    "section": "handbook"
  },
  "processing": {
    "original_length": 14943,
    "cleaned_length": 14912,
    "cleaned_at": "2025-10-27T16:13:42.600951",
    "processor": "text_cleaner_v1",
    "word_count": 2389
  }
}