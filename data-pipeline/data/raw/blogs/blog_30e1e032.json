{
  "content": "Modern businesses entirely depend on web-based platforms for customer interactions, financial\ntransactions, data processing, and core business operations. As digital transformation\naccelerates and remote or hybrid work becomes the norm, the attack surface for web applications has\nexpanded dramatically, making them prime targets for cybercriminals. Therefore, securing web applications has become more critical than ever.\nWhile static code analysis catches vulnerabilities in source code, it cannot identify\nruntime security issues that emerge when applications interact with real-world\nenvironments, third-party services, and complex user workflows. This is where Dynamic\nApplication Security Testing (\nDAST\n) becomes invaluable. GitLab's integrated DAST solution provides teams with automated security testing capabilities directly within their CI/CD pipelines, on a schedule, or on-demand, enabling continuous security validation\nwithout disrupting development workflows.\nWhy DAST?\nDAST should be implemented because it provides critical runtime security validation by testing applications\nin their actual operating environment, identifying vulnerabilities that static analysis cannot detect.\nAdditionally, GitLab DAST can be seamlessly integrated into shift-left security workflows, and\ncan enhance compliance assurance along with risk management.\nRuntime vulnerability detection\nDAST excels at identifying security vulnerabilities that only manifest when applications are running.\nUnlike static analysis tools that examine code at rest, DAST scanners interact with live applications\nas an external attacker would, uncovering issues such as:\nAuthentication and session management flaws\nthat could allow unauthorized access\nInput validation vulnerabilities,\nincluding SQL injection, cross-site scripting (XSS), and command injection\nConfiguration weaknesses\nin web servers, databases, and application frameworks\nBusiness logic flaws\nthat emerge from complex user interactions\nAPI security issues,\nincluding improper authentication, authorization, and data exposure\nDAST complements other security testing approaches to provide comprehensive application security coverage. When combined with Static Application Security Testing (\nSAST\n), Software Composition Analysis (\nSCA\n), manual\npenetration testing, and\nmany other scanner types\n, DAST fills critical gaps in security validation:\nBlack-box testing perspective\nthat mimics real-world attack scenarios\nEnvironment-specific testing\nthat validates security in actual deployment configurations\nThird-party component testing,\nincluding APIs, libraries, and external services\nConfiguration validation\nacross the entire application stack\nSeamless shift-left security integration\nGitLab DAST seamlessly integrates into existing CI/CD pipelines, enabling teams to identify security\nissues early in the development lifecycle. This shift-left approach provides several key benefits:\nCost reduction\nâ Fixing vulnerabilities during development is significantly less expensive than addressing them in production. Studies show that remediation costs can be 10 to 100 times higher in production environments.\nFaster time-to-market\nâ Automated security testing eliminates bottlenecks caused by manual security reviews, allowing teams to maintain rapid deployment schedules while ensuring security standards.\nDeveloper empowerment\nâ By providing immediate feedback on security issues, DAST helps developers build security awareness and improve their coding practices over time.\nCompliance and risk management\nMany regulatory frameworks and industry standards require regular security testing of web applications.\nDAST helps organizations meet compliance requirements for standards such as:\nPCI DSS\nfor applications handling payment card data\nSOC 2\nsecurity controls for service organizations\nISO 27001\ninformation security management requirements\nThe automated nature of GitLab DAST ensures consistent, repeatable security testing that auditors can\nrely on, while detailed reporting provides the documentation needed for compliance validation.\nImplementing DAST\nBefore implementing GitLab DAST, ensure your environment meets the following requirements:\nGitLab version and Ultimate subscription\nâ DAST is available in\nGitLab Ultimate\nand requires GitLab 13.4 or later for full functionality; however, the\nlatest version\nis recommended.\nApplication accessibility\nâ Your application must be accessible via HTTP/HTTPS with a publicly reachable URL or accessible within your GitLab Runner's network.\nAuthentication setup\nâ If your application requires authentication, prepare test credentials or configure authentication bypass mechanisms for security testing.\nBasic implementation\nThe simplest way to add DAST to your pipeline is by including the DAST template in your\n.gitlab-ci.yml\nfile\nand providing a website to scan:\ninclude:\n- template: DAST.gitlab-ci.yml\nvariables:\nDAST_WEBSITE: \"https://your-application.example.com\"\nThis basic configuration will:\nRun a DAST scan against your specified website\nGenerate a security report in GitLab's security dashboard\nFail the pipeline if high-severity vulnerabilities are detected\nStore scan results as pipeline artifacts\nHowever, it is suggested to gain the full benefit of\nCI/CD\n, you can first deploy the application\nand set DAST to run only after an application has been deployed. The application URL can be\ndynamically created and the DAST job can be configured fully with\nGitLab Job syntax\n.\nstages:\n- build\n- deploy\n- dast\ninclude:\n- template: Security/DAST.gitlab-ci.yml\n# Builds and pushes application to GitLab's built-in container registry\nbuild:\nstage: build\nvariables:\nIMAGE: $CI_REGISTRY_IMAGE/$CI_COMMIT_REF_SLUG:$CI_COMMIT_SHA\nbefore_script:\n- docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY\nscript:\n- docker build -t $IMAGE .\n- docker push $IMAGE\n# Deploys application to your suggested target, setsup the dast site dynamically, requires build to complete\ndeploy:\nstage: deploy\nscript:\n- echo \"DAST_WEBSITE=http://your-application.example.com\" >> deploy.env\n- echo \"Perform deployment here\"\nenvironment:\nname: $DEPLOY_NAME\nurl: http://your-application.example.com\nartifacts:\nreports:\ndotenv: deploy.env\ndependencies:\n- build\n# Configures DAST to run a an active scan on non-main branches, and a passive scan on the main branches and requires a deployment to complete before it is run\ndast:\nstage: dast\nrules:\n- if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH\nvariables:\nDAST_FULL_SCAN: \"false\"\n- if: $CI_COMMIT_REF_NAME != $CI_DEFAULT_BRANCH\nvariables:\nDAST_FULL_SCAN: \"true\"\ndependencies:\n- deploy\nYou can learn from an example by seeing the\nTanuki Shop\ndemo application, which generates the\nfollowing pipeline:\nUnderstanding passive vs. active scans\nIn the example above we enabled active scanning for non-default branches:\n- if: $CI_COMMIT_REF_NAME != $CI_DEFAULT_BRANCH\nvariables:\nDAST_FULL_SCAN: \"true\"\nGitLab DAST employs two distinct scanning methodologies (passive and active), each serving\ndifferent security testing needs.\nPassive scans\nanalyze application responses without sending potentially harmful requests. This approach:\nExamines HTTP headers, cookies, and response content for security misconfigurations\nIdentifies information disclosure vulnerabilities like exposed server versions or stack traces\nDetects missing security headers (CSP, HSTS, X-Frame-options)\nAnalyzes SSL/TLS configuration and certificate issues\nActive scans\nsend crafted requests designed to trigger vulnerabilities. This approach:\nTests for injection vulnerabilities (SQL injection, XSS, command injection)\nAttempts to exploit authentication and authorization flaws\nValidates input sanitization and output encoding\nTests for business logic vulnerabilities\nNote:\nThe DAST scanner is set to passive by default.\nDAST has several configuration options that can be applied via environment variables.\nFor a list of all the possible configuration options for DAST, see the\nDAST documentation\n.\nAuthentication configuration\nDAST requires authentication configuration in CI/CD jobs to achieve complete security coverage. Authentication enables DAST to simulate real attacks and test user-specific features only accessible after login. The DAST job typically authenticates by submitting login forms in a browser, then verifies success before continuing to crawl the application with saved credentials. Failed authentication stops the job.\nSupported authentication methods:\nSingle-step login form\nMulti-step login form\nAuthentication to URLs outside the target scope\nHere is an example for a single-step login form in a\nTanuki Shop MR\nwhich adds\nadmin authentication to non-default branches.\ndast:\nstage: dast\nbefore_script:\n- echo \"DAST_TARGET_URL set to '$DAST_TARGET_URL'\" # Dynamically loaded from deploy job\n- echo \"DAST_AUTH_URL set to '$DAST_TARGET_URL'\" # Dynamically loaded from deploy jobs\nrules:\n- if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH\nvariables:\nDAST_FULL_SCAN: \"false\"\n- if: $CI_COMMIT_REF_NAME != $CI_DEFAULT_BRANCH\nvariables:\nDAST_FULL_SCAN: \"true\" # run both passive and active checks\nDAST_AUTH_USERNAME: \"\n[email protected]\n\" # The username to authenticate to in the website\nDAST_AUTH_PASSWORD: \"admin123\" # The password to authenticate to in the website\nDAST_AUTH_USERNAME_FIELD: \"css:input[id=email]\" # A selector describing the element used to enter the username on the login form\nDAST_AUTH_PASSWORD_FIELD: \"css:input[id=password]\" # A selector describing the element used to enter the password on the login form\nDAST_AUTH_SUBMIT_FIELD: \"css:button[id=loginButton]\" # A selector describing the element clicked on to submit the login form\nDAST_SCOPE_EXCLUDE_ELEMENTS: \"css:[id=navbarLogoutButton]\" # Comma-separated list of selectors that are ignored when scanning\nDAST_AUTH_REPORT: \"true\" # generate a report detailing steps taken during the authentication process\nDAST_REQUEST_COOKIES: \"welcomebanner_status:dismiss,cookieconsent_status:dismiss\" # A cookie name and value to be added to every request\nDAST_CRAWL_GRAPH: \"true\" # generate an SVG graph of navigation paths visited during crawl phase of the scan\ndependencies:\n- deploy-kubernetes\nYou can see if the authentication was successful by viewing the job logs:\nOnce this job completes it provides an authentication report which includes screenshots of the login page:\nYou can also see more examples on DAST with authentication in our\nDAST demos\ngroup.\nTo learn more about how to perform DAST with authentication with your specific requirements, see the\nDAST authentication documentation\n.\nWatch this video demonstration of GitLab DAST authentication configuration:\nViewing results in MR\nGitLab's DAST seamlessly integrates security scanning into your development workflow\nby displaying results directly within merge requests:\nThese results include comprehensive vulnerability data within MRs to help developers identify and address\nsecurity issues before code is merged. Here's what DAST typically reports:\nVulnerability details\nVulnerability name and type (e.g., SQL injection, XSS, CSRF)\nSeverity level (Critical, High, Medium, Low, Info)\nCVSS score when applicable\nCommon Weakness Enumeration (CWE) identifier\nConfidence level of the finding\nLocation information\nURL/endpoint where the vulnerability was detected\nHTTP method used (GET, POST, etc.)\nRequest/response details showing the vulnerable interaction\nParameter names that are vulnerable\nEvidence demonstrating the vulnerability\nTechnical context\nDescription of the vulnerability and potential impact\nProof of concept showing how the vulnerability can be exploited\nRequest/response pairs that triggered the finding\nScanner details (which DAST tool detected it)\nRemediation guidance\nSolution recommendations for fixing the vulnerability\nReferences to security standards (OWASP, etc.)\nLinks to documentation for remediation steps\nViewing results in GitLab Vulnerability Report\nFor managing vulnerabilities located in the default (or production) branch, the GitLab Vulnerability Report provides a centralized dashboard for monitoring all security findings (in the default branch) across your entire project or organization. This comprehensive view aggregates all security scan results, offering filtering and sorting capabilities to help security teams prioritize remediation efforts.\nWhen selecting a vulnerability, you are taken to its vulnerability page:\nJust like in merge requests, the vulnerability page provides comprehensive vulnerability data, as seen above. From here you can triage vulnerabilities by assigning them with a status:\nNeeds triage (Default)\nConfirmed\nDismissed (Acceptable risk, False positive, Mitigating control, Used in tests, Not applicable)\nResolved\nWhen a vulnerability status is changed, the audit log includes a note of who changed it, when it was changed, and the reason it was changed. This comprehensive system allows security teams to efficiently prioritize, track, and manage vulnerabilities throughout their lifecycle with clear accountability and detailed risk context.\nOn-demand and scheduled DAST\nGitLab provides flexible scanning options beyond standard CI/CD pipeline integration through\non-demand and scheduled DAST scans. On-demand scans allow security teams and developers to\ninitiate DAST testing manually whenever needed, without waiting for code commits or pipeline triggers.\nThis capability is particularly valuable for ad-hoc security assessments, incident response scenarios,\nor when testing specific application features that may not be covered in regular pipeline scans.\nOn-demand scans can be configured with custom parameters, target URLs, and scanning profiles, making\nthem ideal for focused security testing of particular application components or newly-deployed features.\nScheduled DAST scans provide automated, time-based security testing that operates independently of\nthe development workflow. These scans can be configured to run daily, weekly, or at custom intervals,\nensuring continuous security monitoring of production applications.\nTo learn how to implement on-demand or scheduled scans within your project, see the\nDAST on-demand scan documentation\nDAST in compliance workflows\nGitLab's security policies framework allows organizations to enforce consistent security\nstandards across all projects, while maintaining flexibility for different teams and environments.\nSecurity policies enable centralized governance of DAST scanning requirements, ensuring that\ncritical applications receive appropriate security testing without requiring individual project\nconfiguration. By defining security policies at the group or instance level, security teams can\nmandate DAST scans for specific project types, deployment environments, or risk classifications.\nScan/Pipeline Execution Policies\ncan be configured to automatically trigger DAST scans based on\nspecific conditions such as merge requests to protected branches, scheduled intervals, or deployment events.\nFor example, a policy might require full active DAST scans for all applications before production deployment,\nwhile allowing passive scans only for development branches. These policies can include custom variables,\nauthentication configurations, and exclusion rules that are automatically applied to all covered projects,\nreducing the burden on development teams and ensuring security compliance.\nMerge Request Approval Policies\nprovide an additional layer of security governance by enforcing human\nreview for code changes that may impact security. These policies can be configured to require security team\napproval when DAST scans detect new vulnerabilities, when security findings exceed defined thresholds, or\nwhen changes affect security-critical components. For example, a policy might automatically require approval\nfrom a designated security engineer when DAST findings include high-severity vulnerabilities, while allowing\nlower-risk findings to proceed with standard code review processes.\nTo learn more about GitLab security policies, see the\npolicy documentation\n.\nAdditionally, for compliance, GitLab provides\nSecurity Inventory\nand\nCompliance center\n, which can allow you to oversee\nif DAST is running in your environment and where it is required.\nTo learn more about these features, visit our\nsoftware compliance solutions page\n.\nSummary\nGitLab DAST represents a powerful solution for integrating dynamic security testing into modern development workflows. By implementing DAST in your CI/CD pipeline, your team gains the ability to automatically detect runtime vulnerabilities, maintain compliance with security standards, and build more secure applications without sacrificing development velocity.\nThe key to successful DAST implementation lies in starting with basic configuration and gradually expanding to more sophisticated scanning profiles as your security maturity grows. Begin with simple website scanning, then progressively add authentication, custom exclusions, and advanced reporting to match your specific security requirements.\nRemember that DAST is most effective when combined with other security testing approaches. Use it alongside static analysis, dependency scanning, and manual security reviews to create a comprehensive security testing strategy. The automated nature of GitLab DAST ensures that security testing becomes a consistent, repeatable part of your development process rather than an afterthought.\nTo learn more about GitLab security, check out our\nsecurity testing solutions page\n. To get started with GitLab DAST,\nsign up for a free trial of GitLab Ultimate today\n.",
  "metadata": {
    "title": "A comprehensive guide to GitLab DAST",
    "url": "https://about.gitlab.com/blog/comprehensive-guide-to-gitlab-dast/",
    "published": "2025-09-17T00:00:00.000Z",
    "updated": "2025-09-17T00:00:00.000Z",
    "author": "Fernando Diaz",
    "categories": [],
    "summary": "<p>Modern businesses entirely depend on web-based platforms for customer interactions, financial\ntransactions, data processing, and core business operations. As digital transformation\naccelerates and remote or hybrid work becomes the norm, the attack surface for web applications has\nexpanded dramatically, making them prime targets for cybercriminals. Therefore, securing web applications has become more critical than ever.</p>\n<p>While static code analysis catches vulnerabilities in source code, ",
    "fetched_at": "2025-10-24T18:28:04.347336",
    "source": "gitlab_blog"
  },
  "processing": {
    "content_length": 17588,
    "word_count": 2331,
    "is_relevant": true
  }
}