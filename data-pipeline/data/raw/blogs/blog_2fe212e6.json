{
  "content": "Embedded developers know this cycle well: write code, wait days or weeks to test on a hardware test bench, discover bugs, fix them, then wait again. Virtual testing environments promise faster feedback, but most implementations create new problems such as environment sprawl and escalating costs.\nGitLab's managed lifecycle environments solve these virtual testing challenges. Through virtual environment automation, GitLab accelerates embedded development cycles without the configuration complexity and cost overruns.\nVirtual testing challenges\nVirtual testing environments â simulated hardware setups that replicate embedded system behavior and real-world conditions â offer the potential to reduce hardware bottlenecks. Teams can test firmware on simulated processors, run model-in-the-loop (MIL) tests in MATLAB/Simulink, or verify software on virtual embedded systems without waiting for physical hardware access.\nHowever, teams often implement virtual environments using one of two common approaches, both of which create unsustainable challenges.\nFlawed approach 1: Pipeline lifecycle environments\nPipeline lifecycle environments re-create the entire testing setup for every CI/CD run.\nWhen code changes trigger your CI/CD pipeline, the system provisions infrastructure, installs software simulations, and configures everything from scratch before running tests.\nThis approach works for simple scenarios but becomes inefficient as complexity rises. Consider software-in-the-loop (SIL) testing in a complex virtual environment, for example. Each pipeline run requires complete environment re-creation, including virtual processor provisioning, toolchain installations, and target configurations.\nThese processes can eat up considerable time.\nMoreover, as embedded systems require more sophisticated virtual hardware configurations, the provisioning\ncosts quickly add up.\nTo avoid these rebuild costs and delays, many teams turn to long-lived environments that persist between test runs. But they come with downsides.\nFlawed approach 2: Long-lived environments\nLong-lived environments persist indefinitely\nto avoid constant rebuilding. Developers request these environments from IT or DevOps teams, wait for approval, then need someone to manually provision the infrastructure. These environments are then tied to individual developers/teams rather than specific code changes, and they support ongoing development work across multiple projects.\nWhile this eliminates rebuild overhead,\nit creates environment sprawl.\nEnvironments accumulate without a clear termination date. Infrastructure costs climb as environments consume resources indefinitely.\nLong-lived environments also suffer from\n\"config rot\"\nâ environments retain settings, cached data, or software versions from previous tests that can affect subsequent results. A test that should fail ends up passing due to the residue of previous testing.\nUltimately, managing long-lived environments is a manual process that slows development velocity and increases operational overhead.\nGitLab offers a third approach\nthrough âmanaged lifecycle environments.â This approach captures the benefits of both long-lived and pipeline lifecycle environments while avoiding the drawbacks.\nSolution: Managed lifecycle environments\nGitLab's managed lifecycle environments tie virtual testing setups to merge requests (\nMRs\n) rather than pipeline runs or individual developers. You can also think of them as âmanaged MR test environments.â When you create an MR for a new feature, GitLab automatically orchestrates the provisioning of necessary virtual testing environments. These environments persist throughout the entire feature development process.\nKey benefits\nPersistent environments without rebuilding:\nThe same virtual environment handles multiple pipeline runs as you iterate on your feature. Whether you're running MIL tests in MATLAB/Simulink or SIL tests on specialized embedded processors, the environment remains configured and ready.\nAutomatic cleanup:\nWhen you merge your feature and delete the branch, GitLab automatically triggers environment cleanup, eliminating environment sprawl.\nSingle source of truth:\nThe MR records all build results, test outcomes, and environment metadata in one location. Team members can track progress and collaborate without shuffling between different tools or spreadsheets.\nWatch this overview video to see how managed lifecycle environments work in practice:\nGitLab automates the entire testing workflow. Each time you run firmware tests, GitLab orchestrates testing in the appropriate virtual environment, records results, and provides full visibility into every pipeline run. This approach transforms complex virtual testing from a manual, error-prone process into automated, reliable workflows.\nThe result:\nTeams get reusable environments without runaway costs. And they increase efficiency while maintaining clean, isolated testing setups for each feature.\nSee a demonstration of managed lifecycle environments for testing firmware on virtual hardware:\nBusiness impact\nGitLab's managed lifecycle environments deliver measurable improvements across embedded development workflows. Teams running MIL testing in MATLAB/Simulink and SIL testing on specialized processors like Infineon AURIX or BlackBerry QNX systems no longer face the tradeoff between constant environment rebuilds or uncontrolled environment sprawl. Instead, these complex virtual testing setups persist throughout feature development while automatically cleaning up when complete, enabling:\nFaster product development cycles\nShorter time-to-market\nLower infrastructure costs\nHigher quality assurance\nStart transforming virtual testing today\nDownload âUnlocking agility and avoiding runaway costs in embedded developmentâ\nfor a deeper exploration of managed lifecycle environments and learn how to accelerate embedded development workflows dramatically.",
  "metadata": {
    "title": "How GitLab transforms embedded systems testing cycles",
    "url": "https://about.gitlab.com/blog/how-gitlab-transforms-embedded-systems-testing-cycles/",
    "published": "2025-10-02T00:00:00.000Z",
    "updated": "2025-10-02T00:00:00.000Z",
    "author": "Darwin Sanoy",
    "categories": [],
    "summary": "<p>Embedded developers know this cycle well: write code, wait days or weeks to test on a hardware test bench, discover bugs, fix them, then wait again. Virtual testing environments promise faster feedback, but most implementations create new problems such as environment sprawl and escalating costs.</p>\n<p>GitLab's managed lifecycle environments solve these virtual testing challenges. Through virtual environment automation, GitLab accelerates embedded development cycles without the configuration ",
    "fetched_at": "2025-10-24T18:27:59.135623",
    "source": "gitlab_blog"
  },
  "processing": {
    "content_length": 5937,
    "word_count": 778,
    "is_relevant": true
  }
}